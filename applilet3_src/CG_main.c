/********************************************************************************
* Copyright(C) 2011 Renesas Electronics Corporation
* RENESAS ELECTRONICS CONFIDENTIAL AND PROPRIETARY
* This program must be used solely for the purpose for which
* it was furnished by Renesas Electronics Corporation. No part of this
* program may be reproduced or disclosed to others, in any
* form, without the prior written permission of Renesas Electronics
* Corporation. 
*
* This device driver was created by Applilet3 for RL78/G13
* 16-Bit Single-Chip Microcontrollers
* Filename:	CG_main.c
* Abstract:	This file implements main function.
* APIlib:	Applilet3 for RL78/G13 E1.00b [14 Jan 2011]
* Device:	R5F100LE
* Compiler:	IAR Systems iccrl78
* Creation date:	8/26/2011
*******************************************************************************
*
* NOTE -
* This file is no longer Applilet3-safe, nor is the code up-to-date for new
* versions of Applilet3.  Applilet3 comments have been removed to improve it's
* readability.
* Modified by Andrew Tergis, Jan 2012
*/

/*
*******************************************************************************
** Include files
*******************************************************************************
* Old Applilet3-generated files:
*/
#include "CG_macrodriver.h"
#include "CG_system.h"
#include "CG_port.h"
#include "CG_int.h"
#include "CG_serial.h"
#include "CG_ad.h"
#include "CG_timer.h"
#include "CG_it.h"
/* Redpine Wifi_API */
#include "rsi_data_types.h"
#include "rsi_uart_api.h"
#include "rsi_hal.h"
#include "rsi_global.h"
#include "rsi_hal_api.h"
#include "lcd.h"
#include "rsi_demo_app.h"
#include "PinoutDef.h"
/* Preliminary BUGswarm library */
#include "swarm.h"
#include <stdlib.h>

/* Set option bytes
 * (Generated by Applilet3) */
#pragma location = "OPTBYTE"
__root const UCHAR opbyte0 = 0xEFU;
#pragma location = "OPTBYTE"
__root const UCHAR opbyte1 = 0x35U;
#pragma location = "OPTBYTE"
__root const UCHAR opbyte2 = 0xE8U;   
#pragma location = "OPTBYTE"
__root const UCHAR opbyte3 = 0x84U;
/* Set security ID */
#pragma location = "SECUID"
__root const UCHAR secuid[10] = 
	{0xFFU, 0xFFU, 0xFFU, 0xFFU, 0xFFU, 0xFFU, 0xFFU, 0xFFU, 0xFFU, 0xFFU};

#define LIGHT_WADDR         0x72
#define LIGHT_RADDR         0x73
#define LIGHT_LSB           0x91
#define LIGHT_MSB           0x93
//light sensor is PH5551A2NA1

#define TEMP_WADDR          0x90
#define TEMP_RADDR          0x91
#define TEMP_MSB            0x00
#define TEMP_LSB            0x01
//temp sensor is ADT7420

/* Accelerometer constants */
#define ACCEL_WADDR         0x3A
#define ACCEL_RADDR         0x3B
#define ACCEL_REG_PWRCTL    0x2D
#define ACCEL_REG_DATASTART 0x32
#define ACCEL_CTL_MEASURE   0x08
/* Experimentally determined that a reading of 270 = 1G of acceleration */
#define ACCEL_SCALE 270
/* The sample period, in milliseconds.  This will be limited by BUGswarm.
 * Adjust with care and an eye on a swarm console.
 * NOTE - this isn't a precise value, it does not take into effect the time
 * spent retrieving the sample and sending it out to swarm.*/
#define UPDATE_PERIOD 1000
/* The number of messages to wait until sending out a swarm capabilities message
 */
#define ANNOUNCE_INTERVAL  10

api strApi;
DECLARE_AND_INIT_GLOBAL_STRUCT(api, strApi);
#define LIB_RX_BUF_SIZE       100
#define LIB_NETWORK_HDR_LEN   50

/* Swarm IDs
 * Edit the following values based on desired BUGSwarm configuration */
const char swarm_server_ip[] = "107.20.250.52";  //api.bugswarm.net
//const char swarm_server_ip = "64.118.81.28";  //test.api.bugswarm.net
const char swarm_id[] =          "27e5a0e7e2e5445c51be56de44f45b19701f36d3";
const char resource_id[] =       "b75538642bcadbdf4ae6d242d4f492266c11cb44";
const char participation_key[] = "7a849e6548dbd6f8034bb7cc1a37caa0b1a2654b";

rsi_socketFrame_t      insock_obj;
rsi_socketFrame_t      outsock_obj;

uint8 lib_rx_buffer1[LIB_RX_BUF_SIZE+LIB_NETWORK_HDR_LEN]; 
uint8 lib_rx_buffer2[LIB_RX_BUF_SIZE+LIB_NETWORK_HDR_LEN];

unsigned char i2cbuf[4];/* Buffer for I2C transactions */
signed int datax = 0;   /* Store values to modulate frequency */
signed int datay = 0;   /* Store values to modulate duty cycle */

/* This function is to replace rsi_delayMs, which doesn't seem to work.
 * It may be optimzed out, whereas this function does not.
 * This function will delay program execution for specified number of millis*/
void mydelay(long ms){
  for (long i=0;i<(20*ms);i++)
        asm("NOP");
}

/* This function will retrieve a single sample from the Accelerometer
 * Data returned is loaded into datax and datay global variables
 * This is still raw data, not yet scaled for Gs 
 * Function copied from Renesas YRDKRL78G13 factory demo application */
void getAccelSample(){
  /* Enable accelerometer */
  i2cbuf[0] = ACCEL_REG_PWRCTL;
  i2cbuf[1] = ACCEL_CTL_MEASURE;
  IICA0_MasterSendStart(ACCEL_WADDR, i2cbuf, 2, 32);
  while (IICBSY0);        /* Busy-wait until previous I2C TX is done */

  /* Inform accelerometer of starting address at which to read next */
  i2cbuf[0] = ACCEL_REG_DATASTART; 
  IICA0_MasterSendStart(ACCEL_WADDR, i2cbuf, 1, 32);
  while (IICBSY0);    /* Busy-wait until previous I2C TX is done */

  /* Read x and y data (2 bytes each) from the accelerometer */
  IICA0_MasterReceiveStart(ACCEL_RADDR, i2cbuf, 4, 32);
  while (IICBSY0);    /* Busy-wait until previous I2C RX is done */

  /* Convert the returned x and y data bytes into signed data */
  datax = ((signed int)i2cbuf[1] << 8) | i2cbuf[0];
  datay = ((signed int)i2cbuf[3] << 8) | i2cbuf[2];
}

int getTempSample(){
  
   /* Send config register (high resolution) */
  i2cbuf[0] = 0x03;
  i2cbuf[1] = 0x80;
  IICA0_MasterSendStart(TEMP_WADDR, i2cbuf, 1, 32);
  while (IICBSY0);        /* Busy-wait until previous I2C TX is done */
  
  /* Send register address */
  i2cbuf[0] = 0x00;
  IICA0_MasterSendStart(TEMP_WADDR, i2cbuf, 1, 32);
  while (IICBSY0);        /* Busy-wait until previous I2C TX is done */
  
  /* Read temperature sample */
  IICA0_MasterReceiveStart(TEMP_RADDR, i2cbuf, 2, 32);
  while (IICBSY0);    /* Busy-wait until previous I2C RX is done */
  return (i2cbuf[0] << 8) | i2cbuf[1];
 
}

int getLightSample(){
   
  /* Send register address */
  i2cbuf[0] = LIGHT_LSB;
  IICA0_MasterSendStart(LIGHT_WADDR, i2cbuf, 1, 32);
  while (IICBSY0);        /* Busy-wait until previous I2C TX is done */
  
  /* Read light sample */
  IICA0_MasterReceiveStart(LIGHT_RADDR, i2cbuf, 2, 32);
  while (IICBSY0);    /* Busy-wait until previous I2C RX is done */
  return (i2cbuf[1] << 8) | i2cbuf[0];
 
}

void  main(void)
{
      int16 status = 0;
      char tempbuff[50];
      int16 loopcount = 0;
      
      struct rsi_socketFrame_s *insock = &insock_obj;    
      struct rsi_socketFrame_s *outsock = &outsock_obj;          
      
      /* Put LEDs in off state */
      LED1 = 1;
      LED2 = 1;
      LED3 = 1; 

      /* Initialize UART and enable Module power and reset pins */  
      rsi_init();
     
      /* Register UART HAL buffers */
      rsi_set_rx_buffer(lib_rx_buffer1, (LIB_RX_BUF_SIZE + LIB_NETWORK_HDR_LEN));
      rsi_set_rx_buffer(lib_rx_buffer2, (LIB_RX_BUF_SIZE + LIB_NETWORK_HDR_LEN));
      
      /* Boot WLAN module */
      if(rsi_boot_device () != RSI_NOERROR)
      {
	  ;	
      }
      
      /* Initialize LCD module */
      LCDInit();
      /* Set LCD display Font to small */
      LCDFont(FONT_SMALL);      
      /* Initialize WLAN module, Scan APs, Associate (Join) with AP, configure IP Parameters */
      rsi_wifi_init (strApi.band, &strApi.ScanFrame, &strApi.JoinFrame, &strApi.IPparamFrame);     
      
      // Create listening socket with randomized port*/
      getAccelSample();
      getAccelSample();
      getAccelSample();
      getLightSample();
      int seed = (getLightSample()+getTempSample()+datax+datay)&0xFFFF;
      srand(seed);
      do {
        insock->lport = rand();
      } while (insock->lport < 1024);
      //insock->lport = 80;
      
      memset(tempbuff, '\0', sizeof(tempbuff));
      sprintf(tempbuff, "seed %04X port %04X", seed, insock->lport);
      LCDString(tempbuff, LCDRight(8)-55, 21); 

      // Create outbound socket... 
      outsock->rport = 80;
      outsock->lport = insock->lport;
            
      // EDIT the following IP address is the machine that this board will
      //   attempt to connect to... 
      strcpy(outsock->remote_ip, swarm_server_ip);
      
      LED1 = FALSE;
      
      // OPEN listening socket 
      if( rsi_socket_ltcp_open (insock) != RSI_NOERROR )
      {
          LCDString("insock FAIL", LCDRight(8)-55, 21); 
          return;       //If we cannot open a listening socket, do not continue
      }
      do {
        mydelay(10);
        status = rsi_read_cmd_rsp(&insock->handle);
      } while (status == RSI_ERROR_NO_RX_PENDING);
      if (status != RSI_NOERROR){
          memset(tempbuff, '\0', sizeof(tempbuff));
          sprintf(tempbuff, "insock %X", (signed int)status);
          LCDString(tempbuff, LCDRight(8)-55, 21); 
          return;       //If we cannot open a listening socket, do not continue
      }
      
      // Repeately try to connect to the swarm server until successful 
      do {
        if( rsi_socket_tcp_open (outsock) != RSI_NOERROR )
        {
            LCDString("outsock FAIL", LCDRight(8)-55, 21); 
        }
        do {
          mydelay(10);
          status = rsi_read_cmd_rsp(&outsock->handle);
        } while (status == RSI_ERROR_NO_RX_PENDING);
        if (status != RSI_NOERROR){
            LCDString("Can't connect to", LCDRight(8)-55, 21);
            memset(tempbuff, '\0', sizeof(tempbuff));
            sprintf(tempbuff, "SWARM, retrying E%X", (signed int)status);
            LCDString(tempbuff, LCDRight(8)-55, 31); 
            // Flash LED1 and delay a bit 
            LED1 = TRUE;
            mydelay(1000);
            LED1 = FALSE;
        }
      } while (status != RSI_NOERROR);
      LCDClearLine(3);
      LCDClearLine(4);
      LCDString("Connected!", LCDRight(8)-55, 31);
      
      // open HTTP streaming socket to swarm by sending participation header 
      swarm_send_produce(swarm_id, resource_id, participation_key, outsock);
      mydelay(500);
      // Send capabilities message, assuming a webUI is listening for it 
      capabilities_announce(outsock);
      mydelay(500);
      
      // Main program loop 
      while(1){
        // Scale accelerometer data:
        // -Intentionally concatenate integer divided value
        // -Absolute value, so that we can add our own negative sign 
        getAccelSample();
        int dataxRounded = abs(datax/ACCEL_SCALE);
        int datayRounded = abs(datay/ACCEL_SCALE);
        memset(tempbuff, '\0', sizeof(tempbuff));
        // Create swarm payload for acceleration, and load it into tempbuff.
        // Integer math to compensate for lack fo floating point formatter: 
        // -%c is used to display a negative sign if number is negative
        // -%d. is the whole part of the number
        // -%04d is the fake floating point portion, to 4 places 
        sprintf(tempbuff, "{\"Acceleration\":{\"x\":%c%d.%04d,\"y\":%c%d.%04d}}",
                (datax < 0)?'-':' ', dataxRounded, 
                abs((int)((((long)datax*10000L)/ACCEL_SCALE)-((long)dataxRounded*10000L))),
                (datay < 0)?'-':' ', datayRounded, 
                abs((int)((((long)datay*10000L)/ACCEL_SCALE)-((long)datayRounded*10000L))));
        // Send data to swarm and toggle LED2 
        swarm_produce(tempbuff,outsock);
        mydelay(100);        
        
        // Format accelerometer data for the LCD screen.
        // the same integer math as above with the SWARM payload. 
        memset(tempbuff, '\0', sizeof(tempbuff));
        sprintf(tempbuff, "X: %c%d.%04d",(datax < 0)?'-':' ', dataxRounded, 
                abs((int)((((long)datax*10000L)/270)-((long)dataxRounded*10000L))));
        LCDString(tempbuff, LCDRight(8)-55, 41);
        memset(tempbuff, '\0', sizeof(tempbuff));
        sprintf(tempbuff, "Y: %c%d.%04d",(datay < 0)?'-':' ', datayRounded, 
                abs((int)((((long)datay*10000L)/270)-((long)datayRounded*10000L))));
        LCDString(tempbuff, LCDRight(8)-55, 51);        
        
        
        /*memset(tempbuff, '\0', sizeof(tempbuff));
        // Create swarm payload for light
        sprintf(tempbuff, "{\"Light\":{\"value\":%d}}", getLightSample());
        swarm_produce(tempbuff,outsock);
        mydelay(500);        */
        
        // Clear the lower half of the LCD screen and repaint it with data 
        LCDClearLine(5);
        LCDClearLine(6);
        LCDClearLine(7);
        memset(tempbuff, '\0', sizeof(tempbuff));
        
        LED2 = !LED2;
        mydelay(UPDATE_PERIOD);
        if (++loopcount%ANNOUNCE_INTERVAL == 0){
           capabilities_announce(outsock);
           mydelay(500);
        }
        
      } 
}
