/*
*******************************************************************************
* Copyright(C) 2011 Renesas Electronics Corporation
* RENESAS ELECTRONICS CONFIDENTIAL AND PROPRIETARY
* This program must be used solely for the purpose for which
* it was furnished by Renesas Electronics Corporation. No part of this
* program may be reproduced or disclosed to others, in any
* form, without the prior written permission of Renesas Electronics
* Corporation. 
*
* This device driver was created by Applilet3 for RL78/G13
* 16-Bit Single-Chip Microcontrollers
* Filename:	CG_timer_user.c
* Abstract:	This file implements device driver for TAU module.
* APIlib:	Applilet3 for RL78/G13 E1.00b [14 Jan 2011]
* Device:	R5F100LE
* Compiler:	IAR Systems iccrl78
* Creation date:	8/11/2011
*******************************************************************************
*/

/*
*******************************************************************************
** Include files
*******************************************************************************
*/
#include "CG_macrodriver.h"
#include "CG_timer.h"
/* Start user code for include. Do not edit comment generated here */
#include <stdint.h>
#include <math.h>
/* End user code. Do not edit comment generated here */
#include "CG_userdefine.h"

/*
*******************************************************************************
**  Global define
*******************************************************************************
*/
/* Start user code for global. Do not edit comment generated here */

#define  PI	(float)3.141592654
#define	CARRIER_FREQ		45056uL
#define SAMPLING_CONSTANT	32000000/CARRIER_FREQ

float G_Angle, G_DeltaTheta;
uint8_t G_SpeakerInit = 0;

/* End user code. Do not edit comment generated here */

/*
**-----------------------------------------------------------------------------
**
**  Abstract:
**	This function is INTTM00 interrupt service routine.
**
**  Parameters:
**	None
**
**  Returns:
**	None
**
**-----------------------------------------------------------------------------
*/
#pragma vector = INTTM00_vect
__interrupt void MD_INTTM00(void)
{
	/* Start user code. Do not edit comment generated here */
  
    static unsigned short data1;
	static unsigned char toggle = 0;
	static float tmp1;

	toggle ^= 1;
	
	G_Angle += G_DeltaTheta;
	if (G_Angle >= (2.0*PI))
		G_Angle = G_Angle-(2.0*PI);	// wrap angle

	data1 = (SAMPLING_CONSTANT/2);		// 0 output = 50%

	tmp1 = (( sinf(G_Angle) * ((float)SAMPLING_CONSTANT/2.0f)) - 1); // Now scale the frequency value
	
	data1 += (unsigned short)tmp1;

	if ( (data1 == 0) || (data1 >= SAMPLING_CONSTANT) )
	{
		data1++;	// was 0
	}		

    TAU0_Channel1_ChangeDuty(data1/SAMPLING_CONSTANT);
    TAU0_Channel2_ChangeDuty(data1/SAMPLING_CONSTANT);
  
	/* End user code. Do not edit comment generated here */
}
/*
**-----------------------------------------------------------------------------
**
**  Abstract:
**	This function is INTTM01 interrupt service routine.
**
**  Parameters:
**	None
**
**  Returns:
**	None
**
**-----------------------------------------------------------------------------
*/
#pragma vector = INTTM01_vect
__interrupt void MD_INTTM01(void)
{
	/* Start user code. Do not edit comment generated here */
	/* End user code. Do not edit comment generated here */
}
/*
**-----------------------------------------------------------------------------
**
**  Abstract:
**	This function is INTTM02 interrupt service routine.
**
**  Parameters:
**	None
**
**  Returns:
**	None
**
**-----------------------------------------------------------------------------
*/
#pragma vector = INTTM02_vect
__interrupt void MD_INTTM02(void)
{
	/* Start user code. Do not edit comment generated here */
    
	/* End user code. Do not edit comment generated here */
}
/*
**-----------------------------------------------------------------------------
**
**  Abstract:
**	This function is INTTM04 interrupt service routine.
**
**  Parameters:
**	None
**
**  Returns:
**	None
**
**-----------------------------------------------------------------------------
*/
#pragma vector = INTTM04_vect
__interrupt void MD_INTTM04(void)
{
	/* Start user code. Do not edit comment generated here */
	/* End user code. Do not edit comment generated here */
}
/*
**-----------------------------------------------------------------------------
**
**  Abstract:
**	This function is INTTM05 interrupt service routine.
**
**  Parameters:
**	None
**
**  Returns:
**	None
**
**-----------------------------------------------------------------------------
*/
#pragma vector = INTTM05_vect
__interrupt void MD_INTTM05(void)
{
	/* Start user code. Do not edit comment generated here */
	/* End user code. Do not edit comment generated here */
}
/*
**-----------------------------------------------------------------------------
**
**  Abstract:
**	This function is INTTM06 interrupt service routine.
**
**  Parameters:
**	None
**
**  Returns:
**	None
**
**-----------------------------------------------------------------------------
*/
#pragma vector = INTTM06_vect
__interrupt void MD_INTTM06(void)
{
	/* Start user code. Do not edit comment generated here */
	/* End user code. Do not edit comment generated here */
}

/* Start user code for adding. Do not edit comment generated here */

/*
void TAU0_Audio_Start(void)
{
    TMIF00 = 0U;	// clear INTTM00 interrupt flag 
    TMIF01 = 0U;	// clear INTTM01 interrupt flag 
    TMIF02 = 0U;	// clear INTTM02 interrupt flag 
    
	TMMK00 = 0U;	// enable INTTM00 interrupt 
	TMMK01 = 0U;	// enable INTTM01 interrupt 
	TMMK02 = 0U;	// enable INTTM02 interrupt 
    
    // Simultaneous Start
	TOE0| = _0002_TAU_CH1_OUTPUT_ENABLE | _0004_TAU_CH2_OUTPUT_ENABLE;
	TS0 |= _0001_TAU_CH0_START_TRG_ON | _0002_TAU_CH1_START_TRG_ON | _0004_TAU_CH2_START_TRG_ON;
}

void TAU0_Audio_Stop(void)
{
    // Simultaneous Stop
    TT0 |= _0001_TAU_CH0_STOP_TRG_ON | _0002_TAU_CH1_STOP_TRG_ON | _0004_TAU_CH2_STOP_TRG_ON;
	TOE0 &= ~_0002_TAU_CH1_OUTPUT_ENABLE & ~_0004_TAU_CH2_OUTPUT_ENABLE;
    
    // Mask channel 0 interrupt 
	TMMK00 = 1U;	// disable INTTM00 interrupt 
	TMIF00 = 0U;	// clear INTTM00 interrupt flag 

	// Mask channel 1 interrupt 
	TMMK01 = 1U;	// disable INTTM01 interrupt 
	TMIF01 = 0U;	// clear INTTM01 interrupt flag 

	// Mask channel 2 interrupt 
	TMMK02 = 1U;	// disable INTTM02 interrupt 
	TMIF02 = 0U;	// clear INTTM02 interrupt flag 
}*/

void SpeakerSetFreq(uint32_t aFreq)
{
	G_Angle = 0.0f;
	
	// angle traversed each sample
	G_DeltaTheta = (2.0*PI)*(aFreq/(float)CARRIER_FREQ);
}

void SpeakerON(uint8_t left, uint8_t right)
{
	TAU0_Channel1_ChangeDuty(1);
    TAU0_Channel2_ChangeDuty(1);
    
    TAU0_Channel0_Start();
    
    if(!right)
    {
        // Turn off right
        TT0 |= _0002_TAU_CH1_STOP_TRG_ON;
        TOE0 &= ~_0002_TAU_CH1_OUTPUT_ENABLE;
    }
    
    if(!left) 
    {
        // Turn off left
        TT0 |= _0004_TAU_CH2_STOP_TRG_ON;
	    TOE0 &= ~_0004_TAU_CH2_OUTPUT_ENABLE;
    }
}

void SpeakerOFF()
{
    TAU0_Channel0_Stop();
}

/* End user code. Do not edit comment generated here */
